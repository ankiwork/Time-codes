//Библиотеки
#include <stdio.h>
#include <stdlib.h>
#include <time.h>
#include <locale.h>



//Константы
#define M 5  //Произвольный массив длинной "M"
#define T M - 1  //Произвольный массив длинной "M"




//Начало функции поиска последнего положительного числа(Индекса) массива
int FindMaxLast(int a[M][M], int vvod) {  //Вспомогательная функция



    //Объявление переменных, указателей и т.п.
    int i, j;  //Счёчтики для прохода по массиву
    int ret = 0;  //Возвращаемое значение вспомогательной функции
    int max = 0;


    
    //Основной код(Проход по ЗеЛёНкЕ)
    for (i = 0; i < M; i++) {  //Проход по строкам

        for (j = i + 1; j < M; j++) {  //Проход по правой области

            a[i][j] = abs(a[i][j]);  //Крч, все минусики внутри системы переквалифицируются в плюсики, никто не узнает...
          
        }

    }

    for (i = 0; i < M; i++) {  //Проход по строкам

        for (j = i + 1; j < M; j++) {  //Проход по правой области

            if (a[vvod][j] > max) {  //Читайте ниже

                max = a[i][j];  //Сложно, примите как факт

            }

        }

    }



    //Возвращаемое значение функции
    return max;  //Вернуть значение(Индекс)

}


//Начало главной функции
int main() {  //Главная функция



    //Предустановки
    srand((unsigned int)time(NULL));  //Позволяет генерировать каждый раз "Новые" случайные числа
    setlocale(LC_ALL, "Russian");  //Установка руссификатора



    //Объявление переменных, указателей и т.п.
    int a[M][M];  //Объявление массива
    int i, j;  //Счёчтики для прохода по матрице
    int ret;  //Возвращаемое значение вспомогательной функции "ret" - "return"
    int vvod;  //Введённая с клавитуары строка



    //Основной код(Задание матрицы + деление по областям)
    printf("Введите номер строки: "); scanf_s("%d", &vvod);  //Получили число... Надо ещё проверку оформить... Господи, я запутался, мне лень делать адекватно, пусть будет так через одно место написанно

    while (vvod == 0) {  //

        printf("Номер строки не может равен 0, повторите попытку: "); scanf_s("%d", &vvod);  //ХИХИ 5х

        if (vvod >= M) {  //

            printf("Номер строки не может быть больше или равен кол-ву строк в матрице, повторите попытку: "); scanf_s("%d", &vvod);  //Хихихихи 7х

        }

        if (vvod < 0) {  //

            printf("Номер строки не может быть отрицательной, повторите попытку: "); scanf_s("%d", &vvod);  //Хихихихи 1000x, знаю.. Колхоз...

        }

    }

    while (vvod < 0) {  //Чтобы программу не ломать, вдруг найдутся умники, которые -20 напишут

        printf("Номер строки не может быть отрицательной, повторите попытку: "); scanf_s("%d", &vvod);  //Хихихихи

        if (vvod == 0) {  //

            printf("Номер строки не может равен 0, повторите попытку: "); scanf_s("%d", &vvod);  //ХИХИ 4х

        }

        if (vvod >= M) {

            printf("Номер строки не может быть больше или равен кол-ву строк в матрице, повторите попытку: "); scanf_s("%d", &vvod);  //Хихихихи 6х

        }

    }

    while (vvod >= M) {  //Чтобы программу не ломать, вдруг найдутся умники, которые при матрице 2х2 сотую строку впишут...

        printf("Номер строки не может быть больше чем кол-во строк в матрице, повторите попытку: "); scanf_s("%d", &vvod);  //Хихихихи 2х

        if (vvod < 0) {  //

            printf("Номер строки не может быть отрицательной, повторите попытку: "); scanf_s("%d", &vvod);  //Хихихихи 3x, знаю.. Колхоз...

        }

        if (vvod == 0) {  //

            printf("Номер строки не может равен 0, повторите попытку: "); scanf_s("%d", &vvod);  //ХИХИ 4х

        }

    }

    vvod = vvod - 1;  //Типа умные, запросили строку, а получился индекс.



    //Основной код(Задание матрицы + деление по областям)
    printf("\n\n");  //Отступ для красоты вывода

    for (i = 0; i < M; i++) {  //Проход по строкам

        for (j = 0; j < i; j++) {  //Проход по левой области

            a[i][j] = 1 + rand() % 19 - 10;  //Присвоение элементу матрицы случайного числа от 1 до 9
            printf("\x1B[31m%5d\033[0m", a[i][j]);  //Вывод элемента матрицы в консоль + 5 знакомест под элемент массива

        }

        for (j = j; j < i + 1; j++) {  //Проход по cредней линии

            a[i][j] = 1 + rand() % 19 - 10;  //Присвоение элементу матрицы случайного числа от 1 до 9
            printf("\x1B[33m%5d\033[0m", a[i][j]);  //Вывод элемента матрицы в консоль + 5 знакомест под элемент массива

        }

        for (j = j; j < M; j++) {  //Проход правой области

            a[i][j] = 1 + rand() % 19 - 10;  //Присвоение элементу матрицы случайного числа от 1 до 9
            printf("\x1B[32m%5d\033[0m", a[i][j]);  //Вывод элемента матрицы в консоль + 5 знакомест под элемент массива

        }

        printf("\n\n");  //Двойной отступ для симметричности вывода в консоль относительно "столбцов"

    }

    printf("\n");  //Отступ для красоты вывода в консоль

    ret = FindMaxLast(a, vvod);  //Вызов вспомогательной функции + передать массив "а" + передать нашу обманку балванку(vvod)

    //Основной код(Вывод в консоль индекса)
    printf("Нужная строка: %d\n\n", ret);  //Вывод + отступ для красоты

    //Вызов функции
    for (i = 0; i < T; i++) {

        ret = FindMaxLast(a, i);  //Вызов вспомогательной функции + передать массив "а" + передать нашу обманку балванку(vvod)


        //Основной код(Вывод в консоль индекса)
        printf("%d", i + 1, "строка: %d\n\n", ret);  //Вывод + отступ для красоты

    }
    


    //Возвращаемое значение функции
    return 0;  //Вернуть 0

}
